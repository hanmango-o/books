---
description: Breadth First Search 에 대해 알아보고 이를 활용하는 방법에 대해 살펴봅니다.
---

# BFS

## BFS 란?

***

BFS 탐색이란 너비 우선 탐색으로 그래프/트리 구조에서 너비를 기준으로 완전 탐색하는 기법입니다.

BFS는 DFS와 다르게 Queue 자료구조를 활용하여 구현하며, 시작 노드를 기준으로 같은 depth의 모든 노드를 순차적으로 탐색하는 기법입니다.

### BFS 구조

BFS의 기본적인 구조는 아래와 같습니다.

```cpp
void BFS() {
    queue<type> q; // [1] 초기 Queue 설정
    q.push(first_node); // [2] 시작 노드 push
    
    while(!q.empty()) { // [3] Queue가 비어질 때(모든 노드를 방문할 때)까지 탐색
        type now = q.front(); // [4] 현재 노드 탐색(pop)
        q.pop();
        
        for(int i = 0; i < graph[now].size(); i++) { // [5] 인접 노드 탐색
            int next = graph[now][i];
            if(visited[next]) continue;
            visited[next] = true; // [6] 방문 처리
            q.push(next); // [7] 인접 노드 방문
        }
    }
}
```

#### \[1] Queue 자료구조 설정

BFS는 너비 우선 탐색을 위해 Queue 자료구조를 사용합니다. FIFO 구조를 통해 인접한 노드를 우선하여 방문할 수 있도록 합니다.

#### \[2] 시작 노드 설정

Queue 에 시작 노드를 push하여 해당 노드를 기준으로 인접 노드를 탐색할 수 있도록 합니다.

#### \[3-4] 현재 노드 탐색 및 반복

while 문을 통해 Queue 가 비어질 때까지, 즉 그래프 내 모든 노드를 탐색할 때까지 BFS 탐색을 진행합니다.

현재 Queue에 제일 처음 들어온 노드(Queue 자료구조 내 가장 depth 가 낮은 노드 중 하나)를 pop 하여 현재 노드를 설정합니다.

#### \[5-7] 인접 노드 탐색

현재 노드에 인접한 노드를 탐색합니다. 이접 노드가 발견된다면 해당 노드를 방문처리하고 Queue 에 push하여 모든 노드가 탐색될 수 있도록 합니다.

위 예시에서는 인접리스트를 활용한 그래프를 사용하였습니다.

### BFS 특징

BFS는 아래 특징을 가집니다.

* 발견된 순서대로 기록할 수 있는 Queue 자료구조를 사용합니다.
* 그래프에 연결된 인접 노드가 일렬로 나열되어 있는 것을 확인할 수 있습니다.

## BFS 활용

***

BFS 탐색은 대표적으로 아래의 경우 사용됩니다.

### 그래프/트리 구조에서 완전 탐색

기본적으로 BFS는 그래프/트리 구조에서 완전 탐색을 진행할 때 사용됩니다. DFS와는 다르게 깊이가 아닌 인접 노드를 모두 방문하는 너비를 우선시하며 진행해야 한다면, BFS 를 선택해야 합니다.

### 가중치가 같은 그래프에서 최단 경로 탐색

BFS 로 시작 노드에서 특정 노드까지 탐색할 때, 탐색되는 경로는 최단 경로임이 보장됩니다. 이는 너비 우선 탐색의 특징으로 인접 노드는 모두 탐색이 되야 다음 depth 로 넘어가기 때문에, 결과적으로 도착 노드에 방문한다면 해당 노드까지의 경로는 무조건 최단 경로가 되게 됩니다.

이러한 최단 경로는 지도상에서도 동일하게 적용되며, Backtracking을 통해 지나온 경로를 저장하는 요소가 필요합니다.

{% hint style="warning" %}
단, 최단 경로는 모든 가중치가 동일할 때만 적용할 수 있습니다.

만약 가중치가 다르다면 Dijkstra, Bellman Ford, Floyd Warshall 과 같은 알고리즘을 사용해야 합니다.
{% endhint %}

### 지도 상에서 시뮬레이션

dy dx 테크닉과 함께 지도상에서 BFS를 통해 시뮬레이션을 진행할 수 있습니다. 최단 경로 탐색 뿐만 아니라, 완전 탐색 역시 지도상에서 시뮬레이션이 가능합니다.

시뮬레이션에서 주의할 점은 진행하는 요소가 1개가 아닐 경우와 시간이 지남에 따른 지도의 변화에 유의해야 합니다.

#### 2개의 요소가 동시 진행

대표적인 예시로 `A와 B가 각자 집에서 출발하여 중간에서 만나는 경우`, `시작 지점(A)에서 중간 포인트(B)를 거쳐 도착 지점으로 가는 경우`에서 최단거리를 구하는 문제를 들 수 있습니다.

해당 예시에서는 하나의 요소를 시작 노드로, 나머지 하나의 요소를 도착 지점으로 두고 BFS 탐색을 진행하고 탐색된 경로에서 중앙 인덱스에 해당하는 위치가 두 요소가 만나는 중간 지점이 되게 됩니다.

{% hint style="info" %}
2개 이상의 요소가 동시에 탐색할 때 가장 중요한 것은 Queue의 관리입니다.\
이에 대한 부분은 [#depth](bfs.md#depth "mention")에서 확인할 수 있습니다.
{% endhint %}

#### 3개 이상의 요소가 동시 진행

문제의 조건에 따라 다르겠지만 3개 이상의 요소가 진행된다면 BFS 탐색이 가능한 지 여부부터 파악해야 합니다.

BFS 탐색 역시 완전 탐색이므로 모든 경우를 3개 이상의 요소가 탐색하게 된다면 시간 복잡도에서 문제가 발생할 수 있습니다. 만약 시간 복잡도에서 문제가 발생한다면, 탐색 과정에서 시간 복잡도를 낮추는 조건문을 추가하거나 BFS 가 아닌 DP 또는 문제에 따른 다른 알고리즘을 적용해야 합니다.

#### 지도의 변화에 따른 탐색

일반적인 탐색 과정에서 시간의 경과에 따른 지도 환경의 변화를 함께 고려하여 시뮬레이션 해야 하는 경우가 있습니다. 이러한 경우 지도 환경의 변화를 depth의 변경에 맞춰 ([#depth](bfs.md#depth "mention")) 관리해야 합니다.

## 주의할 점

***

BFS 탐색 시 주의해야 할 점과 해결 방법은 아래와 같습니다.

### Depth 의 변화 확인하기

BFS 탐색은 Queue 자료구조를 사용하기에 자동으로 depth가 낮은 노드부터 처리됩니다.

하지만 이러한 Queue의 특징 때문에 **Queue에 있는 요소들의 depth가 동일하지 않다**는 문제가 발생하게 됩니다. 인접한 노드를 만나면 다음 탐색을 위해 무조건 push 해야 하고, 이러한 push 타이밍을 제어할 수 없으므로 현재 Queue에 어느 정도의 depth를 가진 노드가 동시에 들어있는지 확인이 어렵다는 문제점이 생깁니다.

이러한 문제는 2중 while 문과 큐의 크기를 통해 해결할 수 있습니다.

```cpp
void BFS() {
    queue<int> q;
    int size_q; // [1] 현재 depth의 노드들의 개수를 저장
    
    q.push(1);
    
    while(!q.empty()) {
        size_q = q.size(); // [2] 현재 depth의 노드 개수
        while(size_q--) { // [3] 현재 depth의 모든 노드를 탐색
            int now = q.front();
            q.pop();
            
            for(int i = 0; i < graph[now].size(); i++) {
                q.push(graph[now][i]);
            }
        }
        // [4] 현재 depth 종료
        // Some code after searching all nodes at the current depth
    }
}
```

#### \[1\~3] Queue의 size() 활용

기존 BFS 에서는 하나의 노드를 방문할 때마다 Queue에 인접 노드를 삽입하고 한번의 pop 이 발생하기 때문에 몇개의 인접 노드가 있는지 확인이 어려웠습니다.

하지만, Queue의 사이즈를 기록하고 해당 사이즈 만큼 반복문을 통해 pop 을 수행하여 인접 노드를 모두  탐색하도록 하면 문제를 해결할 수 있습니다. 위와 같이 2중 반복문을 사용한다면 현재 Queue에는 동일한 Depth를 가진 노드만 유지되며 동작하게 됩니다.

#### \[4] depth 종료 이후 조건 처리

2중 while 문의 종료 시점은 그래프에서 동일 depth 의 노드를 모두 탐색 완료한 시점입니다. 해당 부분에서 추가적인 로직 처리가 가능합니다.

### 시간(Depth)에 따른 조건 변화 제어하기

문제에 추가적인 조건이 있고, 시간 변화에 따라 조건도 변화한다면 어떻게 해야 할까요?

위에서 사용한 depth 처리와 함께 조건 변화를 제어할 다른 Queue를 사용하여 문제를 해결할 수 있습니다.

```cpp
void BFS() {
    queue<int> q, cond_q; // 조건 Queue 는 이미 값이 들어 있어야 함
    int size_q;
    q.push(1);
    
    while(!q.empty()) {
        size_q = cond_q.size(); // [1] 현재 시간의 조건 큐 크기
        while(size_q--) { // [2] 동일 depth의 조건 제어
            int cond_now = cond_q.front();
            cond_q.pop();
            
            // Some code for searching another condition
        }
        size_q = q.size(); // [3] 현재 depth의 노드 크기
        while(size_q--) { // [4] 동일 depth의 노드 탐색
            int now = q.front();
            q.pop();
            
            // Some code for searching next node;
        }
    }
}
```

#### \[1]&#x20;
