---
description: 그리디 알고리즘에 대해 알아보고, 탐욕 방식을 적용해야 하는 경우를 살펴봅니다.
---

# Greedy

## Greedy 란?

***

그리디 알고리즘이란 가장 최선의 선택을 반복적으로 수행하며 문제를 해결하는 알고리즘입니다.

특정한 자료구조, 알고리즘의 형태를 띈 것이 아닌 주어진 문제를 해결하는 방법이 탐욕적 선택(최선의 경우를 반복적으로 선택)한다면 그리디하다고 할 수 있습니다.

### 주의할 점

그리디 알고리즘을 시작하기 전에 가장 주의해야 할 것은, 그리디 알고리즘을 사용해도 되는 경우인지 판단하는 것입니다.

그리디는 가장 최선의 선택만을 수행하기 때문에, 완전 탐색처럼 모든 경우를 탐색하고 답을 내리는 알고리즘이 아닙니다. 이에, 그리디 알고리즘을 적용하여 해결한 문제의 답이 최적해가 아닐 가능성이 있습니다.

따라서 최선의 선택을 해도 되는 경우, 즉 그리디 알고리즘을 사용해도 되는 경우를 판단하는 것이 중요합니다.



## Greedy 유형

***

그리디 알고리즘은 최적해를 보장하지 않기 때문에 해당 알고리즘을 사용해도 되는 경우를 판단하는 것이 중요합니다.

아래는 그리디 알고리즘을 사용하여 최적해를 구할 수 있는 유형들입니다.

### 배수 관계의 요소값 선택(Coin Change Problem)

특정 배열(집합)에 요소들이 배수 관계에 있을 때, 문제 조건에 맞는 요소값을 선택하는 문제에서 그리디를 적용할 수 있습니다.

```cpp
int not_greedy[5] = {1, 2, 5, 100, 20}; // 배수 관계 X
int greedy[5] = {5, 10, 20, 100}; // 배수 관계 O
```

위 예시에서 not\_greedy 배열은 각 요소값이 배수 관계가 아니기 때문에 그리디 알고리즘을 적용할 수 없습니다. 반면, greedy 배열의 경우 각 요소값이 5의 배수 관계이기 때문에 그리디를 적용할 수 있습니다.

{% hint style="warning" %}
여기서 배수 관계란 모든 요소들이 서로 배수 관계이여야 함을 의미합니다.

예를 들어 { 10, 50, 70 } 의 경우 배수 관계가 아닙니다.
{% endhint %}

대표적인 문제의 조건은 요소들을 선택하여 합이 K가 되게 할 때, 최소로 선택하는 경우와 같은 선택 조건이 있습니다. 그 외에도 배수 관계의 요소들을 사용하여 문제를 해결하는 경우 그리디를 고려할 수 있습니다.

{% hint style="info" %}
동전 교환 문제 역시 배수 관계에 포함되기에 그리디로 쉽게 해결 가능합니다.\
단, 동전이 일반적인 배수 관계에 있는지 확인해야 합니다.
{% endhint %}

### 연속된 구간 합(조건)의 최대/최소 구하기

특정 배열의 연속된 구간 중 합(또는 그 외 조건)이 최대/최소가 되는 경우 그리디를 사용할 수 있습니다.

```cpp
int vect[5] = {1, -20, 100, 50, -10};
```

위 배열에서 연속된 구간 중 합이 최대가 되는 경우를 그리디로 찾을 때, 아래 조건에 의해 탐색이 가능합니다.

1. 배열의 N - 1 번째 요소까지의 합을 구한다.
2. 만약 N 번째 요소를 더했을 때 합이 음수가 된다면, N번째 요소를 새로운 합으로 하고 현재까지의 합을 버린다.
3. N + 1 번째 요소를 탐색하고 위 과정을 반복한다.

2번에서 합을 버리는 이유는 최대가 되는 합이 음수라면 현재 구간까지의 합을 이용하는 것보다 앞으로 나올 구간을 선택하는 것이 더 큰 합을 찾는 논리적인 방식이기 때문입니다.

### 배낭 문제(Fractional Knapsack)

배낭 문제는 특정 요소들을 쪼개어 담을 수 있을 때, 최대 조건을 만족시켜야 하는 경우를 의미합니다.

예를 들어 각 보석의 가격과 무게가 주어진다면, 쪼개어 담을 수 있는 최소 금액(가격 / 무게)이 가장 큰 값을 우선시 하여 담으면 항상 최대의 가치를 보장하게 됩니다.

```cpp
int K = TOTAL_WEIGHT; // 총 담아야 하는 무게
int answer = 0; // 최대 가치(결과값)
vector<tuple<double, int, int>> sack; // 배낭(가격/무게, 가격, 무게)

// 가격/무게를 기준으로 오름차순 정렬
sort(sack.begin(), sack.end(), greater<tuple<double, int, int>>());
for(int i = 0; i < sack.size() || K > 0; i++) {
    tie(double knap, int cost, int weight) = sack[i];
    if(K - weight >= 0) answer += cost; // 남은 무게가 보석 전체 무게보다 클 경우
    else answer += knap * K; // 남은 무게가 보석 전체보다 작을 경우
    K -= weight; // 남은 무게 설정
}
cout << answer; // 최대 가치 출력
```

### 비용에 따른 최적 선택 문제(허프만 코드)

허프만 코드는 문자열의 압축을 위한 알고리즘입니다. 여기서 주목해야 하는 경우는 압축을 위한 과정에서 그리디가 사용된다는 점입니다.

즉, 특정 행위에 대한 비용이 최적이 되게(최소가 되도록)하는 선택 문제에서도 그리디가 적용 가능합니다.

예를 들어 2개의 숫자를 선택하여 합칠 때, 해당 과정을 통해 발생하는 합 비용이 최소가 되도록 하는 경우에 그리디를 사용할 수 있습니다.

```cpp
int vect[5] = {100, 100, 200, 150};
int answer = 0;

priority_queue<int> pq;
pq.push(vect elements);

while(pq.size() == 1) {
    int n1 = pq.top(); pq.pop();
    int n2 = pq.top(); pq.pop();
    
    answer += (n1 + n2);
    pq.push(n1 + n2);
}
cout << answer;
```

위 경우에서 가장 최적 비용을 선택하는 방법은 매 순간 가장 최소 값들을 선택하여 합하는 것입니다.

즉, 비용에 따라 최적의 결정을 하기 위해 가장 최선의 선택을 하는 방식이 어떤 것인지 찾고 이를 반복적으로 적용하여 문제를 해결하는 그리디 알고리즘을 적용한 것입니다.

{% hint style="info" %}
문제에 따라 최적 비용을 만드는 방식을 다르게 됩니다.\
따라서, 이러한 방식을 먼저 찾고 이를 반복적으로 그리디하게 적용하는 것이 중요합니다.
{% endhint %}

### 활동 선택 문제(Activity Selection Problem)

구간이 있는 활동(시간이 설정되어 있는 활동)의 경우 그리디 알고리즘을 통해 쉽게 해결 가능합니다.

대표적으로 회의실 선택 문제가 이에 해당합니다. 각 회의실을 사용하고 싶은 사람들의 사용 시작 시간과 끝 시간이 주어졌을 때, 가장 많은 사람이 회의실을 사용할 수 있게 하는 방식은 각 회의의 끝 시간을 기준으로 오름차순 정렬하고 겹치지 않는 회의를 순차적으로 선택하는 것입니다.

```cpp
int answer = 0;
vector<pair<int, int>> vect; // (끝시간, 시작시간)
sort(vect.begin(), vect.end());

pair<int, int> now = vect[0];
for(int i = 1; i < vect.size(); i++) {
    pair<int, int> next = vect[1];
    if(now.first > next.second) continue;
    answer++;
    now = next;    
}
cout << answer;
```

### 조건에 맞는 조합 만들기

요소들을 선택하여 만들 수 있는 조합 중, 조건에 부합하는(ex. 합이 최대) 경우를 찾는 문제 역시 그리디를 활용할 수 있습니다.

앞선 연속된 구간이 아닌 경우에도 요소들을 선택하여 집합을 만들고 조건에 맞는 경우에도 항상 최선의 선택을 하며 문제를 해결합니다.
