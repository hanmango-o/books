---
description: DAT(Direct Addressing Table)에 대해 알아보고, 이를 활용하여 알고리즘 문제에 적용합니다.
---

# DAT(Direct Addressing Table)

## Intro

배열이란 index 를 통해 접근 가능한 연속된 데이터 모음을 의미합니다.\
이러한 배열에서 값에 접근하기 위해서는 `[ index ]` 를 사용해야 합니다.

### 배열에서 \[ ] 의 의미

일반 배열에서 `[]` 없이 배열의 이름을 사용하게 될 경우, 해당 배열의 시작 인덱스의 주소값이 리턴되게 됩니다.

{% hint style="info" %}
`int vect[N]` 에서 `vect` 만 사용할 경우, 해당 배열의 시작 인덱스의 주소값  (`&vect[0]`) 과 동일한 의미를 가집니다.
{% endhint %}

즉, `[]` 가 붙었다는 것은 **배열의 시작 주소 + 데이터 타입의 크기 \* 인덱스** 에 접근한다는 의미입니다.

```cpp
int vect[5] = { ... };
vect[2] -> &vect[0] + 8byte * index(2) // 동일!!
```

이러한 점을 활용하여 DAT 기법을 활용할 수 있습니다.



## DAT 활용하기

### 특정 숫자 확인하기

만약 크기 1000 의 배열의 요소값과 크기 10000 인 배열의 요소값을 비교 확인해야 한다면 어떻게 해야 할까요?

가장 단순하지만 명확한 해답은 모든 요소값을 하나하나 확인하는 것입니다.\
이를 위해 반복문을 사용하게 되고, 해당 경우 O(1000 \* 10000) 의 시간이 소요되게 됩니다.

하지만 이런 방법은 배열의 크기가 커지게 된다면 시간복잡도가 커지게 된다는 문제점이 있습니다.

이러한 문제를 DAT를 활용하여 해결할 수 있습니다.

### DAT 활용하기

DAT의 기본 개념은 **배열의 값을 인덱스로 활용한다**는 것입니다.

앞서 살펴본 예시에서 DAT를 적용한다면 아래와 같이 사용됩니다.

```cpp
int vect[1000] = { .... }; // 0 ~ 100 까지의 숫자만 허용
int query[10000] = { .... };
int DAT[100] = { 0 }; // 0으로 초기화 필수!!

for(int i = 0; i < 100; i++) {
    DAT[vect[i]] = 1; // 값을 DAT 배열의 인덱스로 활용
    // 값이 있으면 1, 없으면 0인 상태
}

for(int i = 0; i < 10000; i++) {
    if(DAT[query[i]]) cout << "값 있음"; // qeury 배열에 있는 값이 있는지 DAT 배열을 통해 확인
    else cout << "값 없음";
}
```

배열의 요소값을 DAT 배열에 인덱스 값으로 활용하여 반복문 중첩 없이 문제를 해결할 수 있습니다.

### 왜 사용할까?

기존 반복문 중첩을 통한 탐색은 모든 경우를 선회하며 찾는 방식이기에 시간 복잡도에서 곱 연산이 적용되게 됩니다.

반면, DAT를 활용하게 된다면 배열의 요소값을 인덱스로 활용하게 되므로 DAT 배열의 접근에 필요한 O(1) 선형 시간과 대상 배열만을 선회하는 탐색 시간이 합 연산으로 동작되게 됩니다.

즉, 시간 복잡도를 낮추어 보다 효율적인 프로그래밍이 가능하게 됩니다.

### 언제 사용할까?

DAT 기법은 어떤 요소가 존재하는지 또는 몇 개가 존재하는지 궁금할 때 사용합니다. 이를 정리하면 아래와 같습니다.

#### Case 1. 배열에 특정 요소가 존재하는 지 여부를 확인할 때

특정 숫자 또는 문자가 존재하는 지 확인할 때 사용됩니다. 해당 요소가 존재하면 DAT 배열에 1을 아니면 0을 삽입하여 확인합니다.

문자의 경우 각각의 아스키 코드가 배열의 인덱스 값이 됩니다. 다만, 공간복잡도가 커질 수 있으므로 `-A` 와 같이 시작 문자를 빼주어 0번 인덱스에서 DAT 배열이 시작할 수 있도록 할 수 있습니다.

#### Case 2. 배열에 특정 요소의 개수를 파악할 때

특정 요소를 찾을 때 마다 DAT 배열의 값을 +1 하여 요소의 개수를 파악할 수 있습니다. 찾아야 하는 요소의 값이 많을 경우, 즉 쿼리가 하나가 아닐 경우 유리합니다.

#### Case 3. 오름차순 정렬이 필요할 때

'정렬을 위해 DAT를 사용한다' 라는 의미까지는 아니지만, DAT 배열 역시 배열이므로 순차적인 인덱스를 가지게 됩니다. 이를 활용하여 정렬하지 않고도 정렬과 같은 효과를 낼 수 있습니다.



## 주의할 점

DAT 배열의 경우 어떤 요소를 인덱스로, 어떤 것을 값으로 잡을 지 고민이 필요합니다.

또한, DAT 배열의 요소값이 정해졌다면 해당 요소값이 DAT 배열의 크기와 일치하는지 확인해야 합니다.

\
예를들어, 숫자 1부터 시작하는 경우 DAT 배열의 0번 인덱스를 사용하지 않으므로 이와 같은 부분을 유의해야 합니다.



## Tips

### 오름차순 정렬의 효과

DAT 배열은 값을 인덱스로 두기 때문에 오름차순 정렬되어 있다 라고도 할 수 있습니다.

예를 들어 배열 A 가 있다고 가정할 때, 배열 A에서 존재하는 요소값을 오름차순 정렬하여 출력하라는 문제가 있다면, DAT 배열을 이용해 존재하는 요소값을 DAT 배열을 통해 확인하고 이를 DAT 배열을 선회하여 출력하기만 하면 오름차순 정렬된 효과를 얻을 수 있습니다.

### 문자 확인 시 DAT 배열 생성

문자를 확인하는 과정에서 DAT 배열을 생성해야 한다면, 아스키 코드에서 해당 시작 문자를 빼어 공간 복잡도를 낮출 수 있습니다.

예를 들어, 대문자를 체크하는 DAT 배열은 DAT\['A' - 'Z' + 1] 과 같이 선언 될 수 있습니다. 이는 DAT\[26] 과 동일한 크기의 배열이 생성되게 됩니다.



## Summary

* DAT는 배열의 인덱스에 의미를 부여하는 기법입니다.
* DAT는 어떤 요소의  존재(또는 개수) 여부를 파악할 때 용이합니다.
* DAT 의 시간 복잡도는 `O(1) + O(N + M)` 으로, `DAT 배열 요소 접근 시간 + 기존 배열의 크기 + 쿼리 개수` 의 의미입니다.
* DAT 배열의 장단점은 아래와 같습니다.

| 장점       | 단점              |
| -------- | --------------- |
| 속도가 빠르다. | 공간 복잡도가 커진다.    |
|          | 음수 인덱싱이 불가능하다.  |
|          | 문자열 인덱싱이 불가능하다. |

