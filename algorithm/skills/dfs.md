---
description: Depth First Search 에 대해 알아보고, 이를 활용하여 문제를 해결하는 방법을 살펴봅니다.
---

# DFS

## DFS 란?

***

DFS 는 깊이 우선 탐색으로 특정 노드에서 방문 가능한 모든 노드를 깊이 우선으로 탐색하는 완전 탐색 기법입니다.

### DFS 구조

DFS는 Stack 자료구조나 재귀를 통하여 구현이 가능합니다. 보통의 경우 재귀를 통해 구현합니다.

아래는 재귀를 통해 DFS 를 구현하는 예시입니다.

```cpp
void DFS(int level) {
    // [1] Base case
    if(level == N) {
        // Some Base logic
        return;
    }
    
    for(int i = 0; i < vect.size(); i++) {
        // [2] Recursive case
   
             // Some Recursive logic
        DFS(level + 1); // depth + 1
    }
}
```

문제에 따라 구조는 다양하게 변경될 수 있으나, 기본적으로 깊이 우선 탐색을 위한 재귀문의 구조와 동일합니다.

#### \[1] Base case

DFS 탐색을 종료하고 싶은 조건문에 해당합니다. 각 문제 상황에 맞게 재귀 종료문에 해당합니다.

#### \[2] Recursive case

다음 Depth 로 나아가는 재귀 조건문에 해당합니다. 해당 조건에  따라 다음 레벨로 진행하게 됩니다.

### 탐색 순서에 따른 제어

DFS는 조건에 따라 요소들의 방문 순서를 제어할 수 있습니다.

아래는 예시 노드의 구조이며, 항상 1번 노드에서 시작한다고 가정하겠습니다.

```plaintext
// 1 ~ 6 Node Graph

1 --- 2 --- 4
      |     |
      |     |
5 --- 3     6
```

#### 전위탐색(Pre-Order)

전위탐색은 현재 노드를 먼저 처리하고 이후 다음 노드로 진행하는 탐색을 말합니다.

```cpp
void pre_order(int level) {
    if(level == N) return;
    
    cout << level; // 현재 노드 처리
    for(int i = 0; i < graph[level].size(); i++) {
        pre_order(i); // 다음 노드 진행
    }
}
```

위 예시에서 전위 탐색을 진행한다면, 1 > 2 > 3 > 5 > 4 > 6 순으로 출력되게 됩니다.

전위탐색에서 가장 중요한 것은 현재 노드에서 해야 하는 처리를 다음 노드로 진행하기 이전에 처리한다는 것 입니다. 이에 현재 노드를 나타내는, 즉 Recursive case 이전에 해당 처리를 진행해야 합니다.

#### 중위탐색(In-Order)

중위탐색은 현재 노드를 다음 노드 진행 이후 복귀 과정에서 중간에 처리하는 탐색을 말합니다.

```cpp
void in_order(int level) {
    if(level == N) return;
    
    for(int i = 0; i < graph[i].size(); i++) {
        in_order(i);// 다음 노드 진행
        cout << level; // 현재 노드 처리, 위 예시에서는 중복은 고려하지 않음
    }
}
```

위 예시에서 중위 탐색을 진행하면, 5 > 3 > 2 >  6 > 4 > 1 이 되게 됩니다.

중위 탐색에서 가장 중요한 것은 다음 노드로 진행하되, 복귀 후 바로 현재 노드에 대한 처리를 해줘야 한다는 것입니다. 이에 복귀 이후 다음 노드 탐색 이전, 즉 위 예시에서 반복문 처리 이전에 해당 노드에 대한 처리를 진행합니다.

#### 후위탐색(Post-Order)

후위 탐색은 현재 노드를 가능한 모든 다음 노드의 진행이 끝난 이후에 처리하는 탐색을 말합니다.

```cpp
void post_order(int level) {
    if(level == N) return;
    
    for(int i = 0; i < graph[i].size(); i++) {
        post_order(i); // 다음 노드 진행
    }
    cout << level; // 현재 노드 처리
}
```

위 예시에서 후위 탐색을 진행하면, 5 > 3 > 6 > 4 > 2 > 1 로 탐색되게 됩니다.

후위 탐색에서 가장 중요한 것은 현재 노드에서 갈 수 있는 모든 다음 노드로의 탐색이 다 종료된 후, 현재 노드에 대한 처리를 해줘야 한다는 것입니다. 이에 모든 연결 노드의 처리가 끝난 후 현재 노드의 처리를 진행합니다.

### 요소들의 중복 제어

DFS 탐색을 과정에서 탐색 조건을 설정하여 탐색 결과의 중복을 제어할 수 있습니다.

#### 중복된 요소 없이 탐색

DFS 탐색 간에 중복된 요소 없이 탐색하기 위해서는 해당 요소를 탐색 과정에서 사용했는지 여부를 체크하는 visited 배열이 필요합니다. 이러한 방식은 DAT 배열 활용과 동일한 방식으로 진행됩니다.

예를 들어 앞선 예시는 양방향 그래프 상황이기 때문에 한번 방문한 노드에 대한 처리를 안할 경우 무한 재귀에 빠지게 됩니다.

```cpp
bool visited[N] = { false }; // 방문 노드 기록

void DFS(int level) {
    // Some base case
    
    for( /* Some recursive case...*/ ) {
        visited[node] = true;
        DFS(node);
        visited[node] = false;
    }
}
```

DAT 배열을 활용한 백트랙킹과 마찬가지로 다음 탐색을 위해 재귀문 종료 시 visited 배열을 복구시켜야 합니다.

#### 중복된 결과값 없이 탐색

DFS 탐색 과정에서 3개의 노드 조합을 찾는 상황을 가정한다면, \[1, 2, 3] \[2, 1, 3] 과 같은 조합이 가능할 것 입니다.

이는 앞선 중복된 요소 없이 탐색을 만족하지만, 탐색하고자 하는 요소 조합 간의 순서를 고려하지 않는다면 \[1, 2, 3] 과 \[2, 1, 3] 은 중복된 결과라 할 수 있습니다.

이러한 결과의 중복 없이 탐색하기 위해서는 현재 노드를 기준으로 탐색을 진행하고 다음 노드의 진행은 현재 노드를 제외한 다음 노드부터 탐색을 진행해야 합니다.

```cpp
void DFS(int level) {
    if(level == 3) {
        return;
    }
    
    for(int i = level; i < N; i++) { // level 부터 탐색 시작(중복 제어)
        cout << NODE[level]; // 현재 level 인덱스에 해당하는 노드 처리
        DFS(level + 1); // 현재 level 보다 큰 다음 인덱스로 탐색 진행
    }
}
```

위 예시에서 level 부터 탐색을 시작하면서, 이전에 방문한 노드는 더 이상 탐색을 진행하지 않게 됩니다.

이는 visited 와 유사해 보일 수 있지만, visited 는 결과의 중복을 방지하지는 못하고 동작 속도에서도 차이가 나게 됩니다.

또한, 특정 인덱스를 기준으로 탐색을 진행하기 때문에 기존 DFS 처럼 완전 탐색을 보장한다고 할 수 있습니다.(단, 중복을 제외한다는 조건이 있을 경우에 한 함)



## DFS 활용

***

이러한 DFS를 활용하여 문제를 해결하는 대표적인 경우는 아래와 같습니다.

### 그래프/트리 탐색

기본적으로 DFS 를 활용하여 그래프/트리의 노드를 탐색할 수 있습니다.

단, 한번 방문한 노드를 재 방문하여 무한 재귀문에 빠지는 것을 방지하기 위해 visited 배열을 사용해야 한다는 점에 유의해야 합니다.

### MAP 탐색

DFS 는 MAP 과 같은 N \* N 환경에서도 사용할 수 있습니다.

Dx Dy 테크닉이나 백트랙킹과 같은 기법을 같이 활용하여 재귀적으로 지도를 탐색할 수 있습니다

### 조합 탐색

DFS 를 활용하여 문제 조건에 맞는 조합을 찾을 수도 있습니다.

하지만, DFS 탐색을 통해 조건을 찾을 경우 재귀적으로 모든 조건을 다 탐색하기에 시간 복잡도를 유의해야 합니다.

보통의 경우 탐색을 진행하면서 생기는 경로가 경우에 따라 달라질 경우 DFS 탐색을 활용하며, 경우에 따라 달라지지 않고 모든 경우에서 이전 값을 그대로 활용한다면 DP를 활용합니다.



## 주의할 점

***

DFS 사용 시 주의할 점을 아래와 같습니다.

### 시간 복잡도 초과

DFS 탐색은 재귀적으로 동작하기에 시간 복잡도가 커질 수 있습니다.

보통 N 개의 경우를 N depth 로 탐색할 경우 N^2 의 시간 복잡도를 가진다고 생각합니다.

{% hint style="info" %}
가지치기를 활용하여 시간 복잡도를 줄일 수도 있습니다.

예를 들어 최소값을 구하는 문제의 경우 현재까지의 진행에 누적된 값이 현재까지 구한 최솟값보다 클 경우 더 이상 탐색하는 것은 무의미하므로 더 이상의 depth 로 진행할 필요가 없습니다.
{% endhint %}

### 무한 재귀

DFS 는 재귀함수를 활용하기에 Base case 를 설정하지 않으면 무한 재귀에 빠질 수 있습니다.

또한, 종료문을 정확히 설정하여야 모든 경우에 따른 완전 탐색이 가능합니다.



## Summary

***

* DFS 는 완전 탐색으로 그래프/트리에서 모든 노드를 탐색할 때 사용합니다.
* 재귀를 활용한 전위, 후위, 중위 탐색을 통해 노드 처리 순서를 조절할 수 있습니다.
* DFS는 그래프/트리, 지도 탐색 및 조합에 사용될 수 있습니다.
* DFS 사용 시 재귀함수로 인한 시간 복잡도를 고려해야 합니다.
